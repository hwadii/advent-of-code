#lang racket

(define input (string-split (port->string (open-input-file "./input.txt")) "\n"))
(define (parse-pairs-of-pairs input)
  (define (parse-pair-of-pair pair)
    (string-split pair " -> "))
  (map parse-pair-of-pair input))
(define (parse-pairs input)
  (define parsed-pairs-of-pairs (parse-pairs-of-pairs input))
  (define (parse-pair pair)
    (map string->number (string-split pair ",")))
  (define (make-pair input)
    (cons (car input) (cadr input)))
  (define (split-pairs pairs)
    (map (compose1 make-pair parse-pair) pairs))
  (define (straight-line? line)
    (or (= (caar line) (caadr line)) (= (cdar line) (cdadr line))))
  (map split-pairs parsed-pairs-of-pairs))

(define lines (parse-pairs input))

(define (covered-points lines)
  (define (make-points pairs)
    (let ([start (car pairs)] [end (cadr pairs)])
      (define (make-range pair len)
        (let ([a (car pair)] [b (cdr pair)])
          (if (= a b) (make-list (add1 len) a) (inclusive-range a b (if (> a b) -1 1)))))
      (map (lambda (x y) (cons x y))
           (make-range (cons (car start) (car end)) (abs (- (cdr start) (cdr end))))
           (make-range (cons (cdr start) (cdr end)) (abs (- (car start) (car end)))))))
  (append-map make-points lines))

(define (count-points points)
  (define (count-two-or-more tally)
    (for/fold ([count 0]) ([(point count-covered) tally])
      (if (> count-covered 1) (add1 count) count)))
  (define (tally points [counts (hash)])
    (if (null? points)
      (count-two-or-more counts)
      (tally (cdr points) (hash-update counts (car points) add1 0))))
  (tally points))

(count-points (covered-points lines))
